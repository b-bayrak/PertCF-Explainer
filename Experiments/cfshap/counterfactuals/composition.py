"""
    Author: Emanuele Albini

    Counterfactual method that composes two children methods.
    One as a wrapper and one as a wrapped method.
    The wrapper method will use the counterfactuals generated by the wrapped method as background.
"""

__all__ = [
    'CounterfactualComposition',
    'compose_diverse_counterfactual_method',
]

from copy import deepcopy
import numpy as np
from tqdm import tqdm

from ..base import (
    BaseMultipleCounterfactualMethod,
    MultipleCounterfactualMethodSupportsWrapping,
    MultipleCounterfactualMethodWrappable,
)

class CounterfactualComposition(BaseMultipleCounterfactualMethod):
    def __init__(
        self,
        wrapping_instance: MultipleCounterfactualMethodSupportsWrapping,
        wrapped_instance: MultipleCounterfactualMethodWrappable,
        verbose=True,
    ):

        if wrapping_instance.model != wrapped_instance.model:
            raise ValueError('Models of wrapping and wrapped method differs.')

        super().__init__(wrapping_instance.model, None)

        if not isinstance(wrapped_instance, MultipleCounterfactualMethodWrappable):
            raise ValueError('wrapped_instance do not implement necessary interface.')

        if not isinstance(wrapping_instance, MultipleCounterfactualMethodSupportsWrapping):
            raise ValueError('wrapping_instance do not implement necessary interface.')

        # Scalers are ignored (they are already into the wrapped/wrapping instances)
        super().__init__(wrapping_instance.model, scaler=None)

        wrapping_instance = deepcopy(wrapping_instance)
        wrapped_instance = deepcopy(wrapped_instance)

        wrapped_instance.verbose = 0

        self.wrapping_instance = wrapping_instance
        self.wrapped_instance = wrapped_instance

        self.data = None
        self.verbose = verbose

    def get_multiple_counterfactuals(self, X):
        X = self.preprocess(X)

        # Get underlying counterfactuals
        X_Cs = self.wrapped_instance.get_multiple_counterfactuals(X)

        iters = enumerate(zip(X, X_Cs))
        if len(X) > 100 and self.verbose:
            iters = tqdm(iters, desc='Composition CF: Step 2')

        # Postprocess them
        for i, (x, X_C) in iters:
            # Set background
            self.data = self.wrapping_instance.data = X_C

            # Compute counterfactuals
            X_Cs[i] = self.wrapping_instance.get_multiple_counterfactuals(np.array([x]))[0]

        return X_Cs


def compose_diverse_counterfactual_method(*args, **kwargs):
    if len(args) < 2:
        raise ValueError('At least 2 counterfactual methods methods must be passed.')

    # Most inner
    composition = args[-1]

    # Iteratively compose
    for wrapping_instance in args[-2::-1]:
        composition = CounterfactualComposition(wrapping_instance, composition, **kwargs)

    return composition
